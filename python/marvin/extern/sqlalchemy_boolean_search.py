# Copyright 2015 SolidBuilds.com. All rights reserved.
#
# Authors: Ling Thio <ling.thio@gmail.com>

"""
SQLAlchemy-boolean-search
=========================
SQLAlchemy-boolean-search translates a boolean search expression such as::

    field1=*something* and not (field2==1 or field3<=10.0)

into its corresponding SQLAlchemy query filter.

Install
-------

    pip install sqlalchemy-boolean-search

Usage example
-------------

    from sqlalchemy_boolean_search import parse_boolean_search

    # DataModel defined elsewhere (with field1, field2 and field3)
    from app.models import DataModel

    # Parse boolean search into a parsed expression
    boolean_search = 'field1=*something* and not (field2==1 or field3<=10.0)'
    parsed_expression = parse_boolean_search(boolean_search)

    # Retrieve records using a filter generated by the parsed expression
    records = DataModel.query.filter(parsed_expression.filter(DataModel))

Documentation
-------------
http://sqlalchemy-boolean-search.readthedocs.org/

Authors
-------
* Ling Thio - ling.thio [at] gmail.com

Revision History
--------
2016-03-5: Modified to allow for a list of ModelClasses as input - Brian Cherinka
2016-03-11: Modified to output a dictionary of parameters: values - B. Cherinka
2016-03-16: Changed sqlalchemy values in conditions to bindparam for post-replacement - B. Cherinka

"""

from __future__ import print_function
import pyparsing as pp
import inspect
from pyparsing import ParseException  # explicit export
from sqlalchemy import func, bindparam
from sqlalchemy.sql import or_, and_, not_, sqltypes


# Define a custom exception class
class BooleanSearchException(Exception):
    pass


# ***** Utility functions *****
def get_field(DataModelClass, field_name):
    """ Returns a SQLAlchemy Field from a field name such as 'name' or 'parent.name'.
        Returns None if no field exists by that field name.
    """
    # Handle hierarchical field names such as 'parent.name'
    if '.' in field_name:
        relationship_name, field_name = field_name.split('.', 1)
        relationship = getattr(DataModelClass, relationship_name)
        return get_field(relationship.property.mapper.entity, field_name)

    # Handle flat field names such as 'name'
    return getattr(DataModelClass, field_name, None)


# ***** Define the expression element classes *****

class Condition(object):
    """ Represents a 'name operand value' condition,
        where operand can be one of: '<', '<=', '=', '==', '!=', '>=', '>'.
    """
    def __init__(self, data):
        self.name = data[0][0]
        self.op = data[0][1]
        self.value = data[0][2]
        if self.name not in params:
            #params.append(self.name)
            params.update({self.name: self.value})

    def filter(self, DataModelClass):
        ''' Return the condition as an SQLalchemy query condition '''

        condition = None
        if inspect.ismodule(DataModelClass):
            models = [i[1] for i in inspect.getmembers(DataModelClass, inspect.isclass) if hasattr(i[1], '__tablename__')]
        else:
            if isinstance(DataModelClass, list):
                models = DataModelClass
            else:
                models = None

        if models:
            # Input is a a list of DataModelClasses
            field = None
            index = None
            for i, model in enumerate(models):

                field = get_field(model, self.name)
                try:
                    ptype = field.type
                    ilike = field.ilike
                except AttributeError as e:
                    ptype = None
                    ilike = None

                if field and ptype and ilike:
                    index = i
                    break

            if not field:
                raise BooleanSearchException(
                    "Table '%(table_name)s' does not have a field named '%(field_name)s'."
                    % dict(table_name=model.__tablename__, field_name=self.name))

            condition = self.filter_one(models[index], field=field, condition=condition)

        else:
            # Input is only one DataModelClass
            field = get_field(DataModelClass, self.name)
            if field:
                condition = self.filter_one(DataModelClass)
            else:
                raise BooleanSearchException(
                    "Table '%(table_name)s' does not have a field named '%(field_name)s'."
                    % dict(table_name=DataModelClass.__tablename__, field_name=self.name))

        return condition

    def filter_one(self, DataModelClass, field=None, condition=None):
        """ Return the condition as a SQLAlchemy query condition
        """
        if field:
            # Prepare field and value
            lower_field = func.lower(field)
            value = self.value
            lower_value = func.lower(value)

            if field.type.python_type == float:
                try:
                    value = float(value)
                    lower_field = field
                    lower_value = value
                except:
                    raise BooleanSearchException(
                        "Field '%(name)s' expects a float value. Received value '%(value)s' instead."
                        % dict(name=self.name, value=self.value))
            elif field.type.python_type == int:
                try:
                    value = int(value)
                    lower_field = field
                    lower_value = value
                except:
                    raise BooleanSearchException(
                        "Field '%(name)s' expects an integer value. Received value '%(value)s' instead."
                        % dict(name=self.name, value=self.value))

            # Return SQLAlchemy condition based on operator value
            # self.name is parameter name, lower_field is Table.parameterName
            if self.op == '==':
                condition = lower_field.__eq__(bindparam(self.name, lower_value))
            elif self.op == '<':
                condition = lower_field.__lt__(bindparam(self.name, lower_value))
            elif self.op == '<=':
                condition = lower_field.__le__(bindparam(self.name, lower_value))
            elif self.op == '>':
                condition = lower_field.__gt__(bindparam(self.name, lower_value))
            elif self.op == '>=':
                condition = lower_field.__ge__(bindparam(self.name, lower_value))
            elif self.op == '!=':
                condition = lower_field.__ne__(bindparam(self.name, lower_value))
            elif self.op == '=':
                # this operator maps to LIKE
                # x=5 -> x LIKE '%5%' (x contains 5)
                # x=5* -> x LIKE '5%' (x starts with 5)
                field = getattr(DataModelClass, self.name)
                value = self.value
                if value.find('*') >= 0:
                    value = value.replace('*', '%')
                    condition = field.ilike(bindparam(self.name, value))
                else:
                    condition = field.ilike('%'+bindparam(self.name, value)+'%')

        return condition

    def __repr__(self):
        return self.name + self.op + self.value


class BoolNot(object):
    """ Represents the boolean operator NOT
    """
    def __init__(self, data):
        self.condition = data[0][1]
        if isinstance(self.condition, Condition) and self.condition.name not in params:
            #params.append(self.condition.name)
            params.update({self.condition.name: self.condition.value})

    def filter(self, DataModelClass):
        """ Return the operator as a SQLAlchemy not_() condition
        """
        return not_(self.condition.filter(DataModelClass))

    def __repr__(self):
        return 'not_(' + repr(self.condition) + ')'


class BoolAnd(object):
    """ Represents the boolean operator AND
    """
    def __init__(self, data):
        #self.conditions = [condition for condition in data[0] if condition and condition != 'and']
        self.conditions = []
        for condition in data[0]:
            if condition and condition != 'and':
                self.conditions.append(condition)
                if isinstance(condition, Condition) and condition.name not in params:
                    #params.append(condition.name)
                    params.update({condition.name: condition.value})

    def filter(self, DataModelClass):
        """ Return the operator as a SQLAlchemy and_() condition
        """
        conditions = [condition.filter(DataModelClass) for condition in self.conditions]
        return and_(*conditions)  # * converts list to argument sequence

    def __repr__(self):
        return 'and_(' + ', '.join([repr(condition) for condition in self.conditions]) + ')'


class BoolOr(object):
    """ Represents the boolean operator OR
    """
    def __init__(self, data):
        #self.conditions = [condition for condition in data[0] if condition and condition != 'or']
        self.conditions = []
        for condition in data[0]:
            if condition and condition != 'or':
                self.conditions.append(condition)
                if isinstance(condition, Condition) and condition.name not in params:
                    #params.append(condition.name)
                    params.update({condition.name: condition.value})

    def filter(self, DataModelClass):
        """ Return the operator as a SQLAlchemy or_() condition
        """
        conditions = [condition.filter(DataModelClass) for condition in self.conditions]
        return or_(*conditions)  # * converts list to argument sequence

    def __repr__(self):
        return 'or_(' + ', '.join([repr(condition) for condition in self.conditions]) + ')'

# ***** Define the boolean condition expressions *****

# Define expression elements
number = pp.Regex(r"[+-]?\d+(:?\.\d*)?(:?[eE][+-]?\d+)?")
name = pp.Word(pp.alphas + '._', pp.alphanums + '._')
operator = pp.Regex("==|!=|<=|>=|<|>|=")
value = pp.Word(pp.alphanums + '_.*') | pp.QuotedString('"') | number
condition = pp.Group(name + operator + value)
condition.setParseAction(Condition)

# Define the expression as a hierarchy of boolean operators
# with the following precedence: NOT > AND > OR
expression_parser = pp.operatorPrecedence(condition, [
    (pp.CaselessLiteral("not"), 1, pp.opAssoc.RIGHT, BoolNot),
    (pp.CaselessLiteral("and"), 2, pp.opAssoc.LEFT, BoolAnd),
    (pp.CaselessLiteral("or"), 2, pp.opAssoc.LEFT, BoolOr),
])

params = {}


def parse_boolean_search(boolean_search):
    """ Parses the boolean search expression into a hierarchy of boolean operators.
        Returns a BoolNot or BoolAnd or BoolOr object.
    """
    global params
    params = {}
    try:
        expression = expression_parser.parseString(boolean_search)[0]
        expression.params = params
        return expression
    except ParseException as e:
        raise BooleanSearchException("Syntax error at offset %(offset)s." % dict(offset=e.col))

